{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8df12e1f_a4db1ae9",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCaches.java",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-12-10T21:14:04Z",
      "side": 1,
      "message": "I don\u0027t believe this is correct: we would risk to double the cache size regardless, which is a wasteful diverging behaviour.\n\nThe correct formula should be:\n\n    long currMaxEntries \u003d currCache.getConfig().getMaxEntries();\n    long currFreeEntries \u003d currMaxEntries * 100 / currCache.getStore().percentageFreeSpace();\n    return getOptionalMaxEntries()\n        .orElse(\n            Math.max(\n                currMaxEntries,\n                (currMaxEntries - currFreeEntries) * DEFAULT_MAX_ENTRIES_MULTIPLIER));",
      "range": {
        "startLine": 218,
        "startChar": 4,
        "endLine": 218,
        "endChar": 94
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79ac3b12_45ee2b7d",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCaches.java",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-10T22:13:22Z",
      "side": 1,
      "message": "I am not sure this is right, because it\u0027s not considering the maxBloatFactor.\n\nThe percentageFreeSpace [1] value is a function of maxBloatFactor too and it will _increase_ when the cache expands.\n\nSo that that PercentageFreeSpace might go from 2% to, say 80%, on a cache that just expanded.\n\nThe right algorithm should also factor in how many times the cache expanded, but I am not sure that metric is available.\n\nI think we need to test this behaviour first to make sure it does what we want.\n\nWDYT?\n\n[1]https://javadoc.io/static/net.openhft/chronicle-map/3.20.83/net/openhft/chronicle/map/ChronicleMap.html#percentageFreeSpace--",
      "parentUuid": "8df12e1f_a4db1ae9",
      "range": {
        "startLine": 218,
        "startChar": 4,
        "endLine": 218,
        "endChar": 94
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba997c27_23dc3c97",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCaches.java",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-12-10T23:23:00Z",
      "side": 1,
      "message": "True, then the most accurate measure is:\n\n    long currMaxEntries \u003d currCache.getConfig().getMaxEntries();\n    long currEntries \u003d currCache.getStore().entrySet().size();\n    long newMaxEntries \u003d\n        getOptionalMaxEntries()\n            .orElse(Math.max(currMaxEntries, currEntries * DEFAULT_MAX_ENTRIES_MULTIPLIER));\n            \nBy getting the size of the entrySet of the underlying store, we get exactly the number of items that are currently in the cache, including the expansions that happened.\n\nWDYT?",
      "parentUuid": "79ac3b12_45ee2b7d",
      "range": {
        "startLine": 218,
        "startChar": 4,
        "endLine": 218,
        "endChar": 94
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d0ce363_b0eb8f7b",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCaches.java",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-13T09:14:01Z",
      "side": 1,
      "message": "\u003e True, then the most accurate measure is:\n\u003e \n\u003e     long currMaxEntries \u003d currCache.getConfig().getMaxEntries();\n\u003e     long currEntries \u003d currCache.getStore().entrySet().size();\n\u003e     long newMaxEntries \u003d\n\u003e         getOptionalMaxEntries()\n\u003e             .orElse(Math.max(currMaxEntries, currEntries * DEFAULT_MAX_ENTRIES_MULTIPLIER));\n\u003e             \n\u003e By getting the size of the entrySet of the underlying store, we get exactly the number of items that are currently in the cache, including the expansions that happened.\n\nI don\u0027t think this works either.\nGetting the number of entries in the cache does not necessarily tell you how much the cache is used.\n\nImagine this scenario:\n\n- maxEntries 10\n- maxBloatFactor 3\n- avgKeySize 2048 (2kb)\n- avgValueSize 1024 (1kb)\n\nThis means that if all your keys/values were _exactly_ adhering to those averages, you would have no fragmentation and you would be able to store _exactly_ 10 entries without blowing the cache.\n\nIn this scenario, the algorithm you suggested works.\n\nBut imagine now, more realistically, that you are storing keys/values that are slightly (or even very) different from your estimated averages.\n\nIf you store an entry that is massive, for example, you will burn more space more quickly.\nImagine you have 3 entries in your cache:\n\n1 - (k:7Kb, v: 1kb)\n2 - (k:5Kb, v: 5kb)\n2 - (k:6Kb, v: 4kb)\n\nIn this scenario, the cache is pretty much full even though you have stored much fewer than 10 entries.\n\nSo counting the number of entries in your cache will not necessarily tell you how much your cache is full.\n\nPerhaps we should be looking at `remainingAutoResizing` [1] to figure out the status of the cache.\n\nLet me see if that\u0027s the case.\n\n[1]https://javadoc.io/static/net.openhft/chronicle-map/3.20.83/net/openhft/chronicle/map/ChronicleMap.html#remainingAutoResizes--",
      "parentUuid": "ba997c27_23dc3c97",
      "range": {
        "startLine": 218,
        "startChar": 4,
        "endLine": 218,
        "endChar": 94
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e33650d9_0035694c",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCaches.java",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-14T11:50:27Z",
      "side": 1,
      "message": "I think I have found a viable solution.\n\nUsing `remainingAutoResizes` does not help because it does not tell what is the MAXIMUM number of possible resizes.\nWe know that when `remainingAutoResizes` drops to zero, we are in trouble, but by just looking at that value we wouldn\u0027t know how much the cache is actually been utilized, including all its possible resizes.\n\nLooking at its definition however [1], we can see that is calculated:\n\n```\nmaxTiers (i.e. maximum number of resizes) - tiersUsed (used number of resizes)\n```\n\nIn turn, the maximum number of available resizes is calculated as [2] \n\n```\nmaxBloatFactor * actualSegments\n```\n\nGiven the above, we can calculate the percentage of cache utilization (inclusive of all possible resizes) by:\n\n```\nusedResizes * 100 / maxResizes;\n```\n\nWhich is what I have implemented in the newest patchset.\n\n\n[1]https://github.com/OpenHFT/Chronicle-Map/blob/ea/src/main/java/net/openhft/chronicle/map/VanillaChronicleMap.java#L277\n\n[2]https://github.com/OpenHFT/Chronicle-Map/blob/ea/src/main/java/net/openhft/chronicle/map/VanillaChronicleMap.java#L270",
      "parentUuid": "0d0ce363_b0eb8f7b",
      "range": {
        "startLine": 218,
        "startChar": 4,
        "endLine": 218,
        "endChar": 94
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8636bcaf_6d5ce12e",
        "filename": "src/main/resources/Documentation/tuning.md",
        "patchSetId": 2
      },
      "lineNbr": 173,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-12-10T21:14:04Z",
      "side": 1,
      "message": "This is incorrect: it would raise the number of max entries only if the current utilisation is over 50%",
      "range": {
        "startLine": 172,
        "startChar": 0,
        "endLine": 173,
        "endChar": 36
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "023b551f_d36ad59d",
        "filename": "src/main/resources/Documentation/tuning.md",
        "patchSetId": 2
      },
      "lineNbr": 173,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-14T11:50:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8636bcaf_6d5ce12e",
      "range": {
        "startLine": 172,
        "startChar": 0,
        "endLine": 173,
        "endChar": 36
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b892806_4e9614ca",
        "filename": "src/main/resources/Documentation/tuning.md",
        "patchSetId": 2
      },
      "lineNbr": 176,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-12-10T21:14:04Z",
      "side": 1,
      "message": "using",
      "range": {
        "startLine": 176,
        "startChar": 62,
        "endLine": 176,
        "endChar": 68
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc229863_ec6df7d5",
        "filename": "src/main/resources/Documentation/tuning.md",
        "patchSetId": 2
      },
      "lineNbr": 176,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-14T11:50:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5b892806_4e9614ca",
      "range": {
        "startLine": 176,
        "startChar": 62,
        "endLine": 176,
        "endChar": 68
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c8f103a_8713f919",
        "filename": "src/test/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCachesIT.java",
        "patchSetId": 2
      },
      "lineNbr": 119,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2021-12-10T21:14:04Z",
      "side": 1,
      "message": "This is incorrect: it should not have changed unless there was over 50% of the entries used in cache.",
      "range": {
        "startLine": 119,
        "startChar": 21,
        "endLine": 119,
        "endChar": 41
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98e81f72_d11e8d23",
        "filename": "src/test/java/com/googlesource/gerrit/modules/cache/chroniclemap/AutoAdjustCachesIT.java",
        "patchSetId": 2
      },
      "lineNbr": 119,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2021-12-14T11:50:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5c8f103a_8713f919",
      "range": {
        "startLine": 119,
        "startChar": 21,
        "endLine": 119,
        "endChar": 41
      },
      "revId": "ce45a571ea6351699770e0085acae1ad4e3298da",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}