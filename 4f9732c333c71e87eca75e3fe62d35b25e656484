{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bcfc4a7d_dbbea45d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "I do see a lot of performance issues with this implementation.\nAlso, the cleanup policy doesn\u0027t look right, as it doesn\u0027t use the standard Gerrit\u0027s cache configuration for it.",
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46fe451f_f0bc6d92",
        "filename": "config.md",
        "patchSetId": 5
      },
      "lineNbr": 91,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "Shouldn\u0027t the cache cleanup happen also when:\n- repositoryCacheCleanupDelay is triggered\n- repositoryCacheExpireAfter is the threshold for removing all the entries older than that",
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cdb0966_3f287db6",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 220,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "Shouldn\u0027t we just evict all entries that have expired?",
      "range": {
        "startLine": 220,
        "startChar": 11,
        "endLine": 220,
        "endChar": 14
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb9aa429_e7231ba7",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 220,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-21T14:51:08Z",
      "side": 1,
      "message": "Eviction of entries that expired happens at L213-L214, but it might still not be enough.\nIf, after evicting all expired entries (if any), we are still \"runningOutOfFreeSpace\", then the evictLRU() routine will kick off.\n\nAlso bear in mind that not every cache might be set for expiration (maxAge is an optional parameter).",
      "parentUuid": "3cdb0966_3f287db6",
      "range": {
        "startLine": 220,
        "startChar": 11,
        "endLine": 220,
        "endChar": 14
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b50819b_0fc560fc",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 220,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-23T22:29:54Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cb9aa429_e7231ba7",
      "range": {
        "startLine": 220,
        "startChar": 11,
        "endLine": 220,
        "endChar": 14
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23db05ee_2b7ce41c",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 230,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "This is going to be *veeery* CPU intensive: do we really need it?",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 230,
        "endChar": 76
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5edfda89_bb0403f1",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 230,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-21T14:51:08Z",
      "side": 1,
      "message": "yeah, this is what I was referring to in my comments about chroniclemap not supporting ordering and LRU.\n\nWe do need it, in the sense that we need _some_ way to do eviction.\nBu absolutely we need to find a more performant way to do it.",
      "parentUuid": "23db05ee_2b7ce41c",
      "range": {
        "startLine": 226,
        "startChar": 0,
        "endLine": 230,
        "endChar": 76
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8aef6f12_60e2c8ca",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 237,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "I believe removing the expired entries should be enough, isn\u0027t it?",
      "range": {
        "startLine": 232,
        "startChar": 0,
        "endLine": 237,
        "endChar": 11
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccc8afea_54134ab0",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 5
      },
      "lineNbr": 237,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-21T14:51:08Z",
      "side": 1,
      "message": "as I mentioned above: entries do not necessarily expire and removing expired entries might not be enough to get back under threshold (imagine only 1 entry expired, for example).",
      "parentUuid": "8aef6f12_60e2c8ca",
      "range": {
        "startLine": 232,
        "startChar": 0,
        "endLine": 237,
        "endChar": 11
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ba22cf8_099e9203",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "Are we really going to update the value every time we get an entry in the cache?\nThat would create a huge overhead, isn\u0027t it?",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bf34b78_d4f49e1c",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-21T14:51:08Z",
      "side": 1,
      "message": "We could update the value every time is _loaded_ from disk, in a similar way to what H2 does.\nBut perhaps we should change approach completely and only keeping this value in memory.",
      "parentUuid": "3ba22cf8_099e9203",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37f2f1ec_823cda49",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-23T22:29:54Z",
      "side": 1,
      "message": "I believe we should store it as well, otherwise when you restart Gerrit you don\u0027t have a clue of what are the most accessed values in the persisted cache.",
      "parentUuid": "2bf34b78_d4f49e1c",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0cf4818_5890af95",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-26T10:25:59Z",
      "side": 1,
      "message": "Actually, I don\u0027t think storing accessed timestamp is going to help.\n\nBecause chronicle-map cannot support LRU, having a very granular lastAccessedTime is not much of a use: we cannot use it for sorting and find the oldest element of the cache to remove.\nDoing so would require an entire scan of the cache and also to keep updating the value on disk, when each element is accessed.\n\nI would like to suggest an alternative approach:\n\nTo separate \"hot\" entries from \"non-hot\" entries and, when required, delete from the \"non-hot\" entries bucket, randomly.\n\nThe pseudo-algorithm would be like:\n\n- For each cache, allocate a sorted map \"hotEntries\" (10% of cache size, perhaps configurable?)\n- Each time a cache element is accessed:\n   * Add/Update \"hotEntries\", if there\u0027s space (time for this will cost O(1))\n   * Remove the oldest \"hotEntry\" and add the new one (time for this will cost O(logn))\n\n- When cache file free space falls under \"percentageFreeSpaceEvictionThreshold\":\n  * loop through elements in the cache, in random order\n  * if element is not in hotEntries, remove it.\n  * Repeat until free space goes over \"percentageFreeSpaceEvictionThreshold\" again.\n\nBasically the idea is: If computationally, we cannot afford to do LRU, we can at least categorize into recent and non-recent buckets.\n\nSure, when gerrit is restarted, we\u0027ll loose the most accessed values in the persisted cache, but the values are still going to be *in-cache* so performance is not impacted by this immediately and the \"hotEntries\" will be populated quickly as Gerrit gets used.\n\nWDTY? Worth giving it a try?",
      "parentUuid": "37f2f1ec_823cda49",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1b6f052_b0cab414",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-26T16:17:47Z",
      "side": 1,
      "message": "The approach sounds interesting. However, I do not see in the above approach how we can prevent the eviction of hot entries after a restart.\n\nImagine that we go beyond the diskLimit, so a restart would trigger the cleanup, correct?\n\nBecause we are restarting Gerrit and the the fact of an entry being in the hot-list isn\u0027t persisted, anything in the cache would be non-hot, and therefore will be subject to eviction.\n\nAny ideas?",
      "parentUuid": "f0cf4818_5890af95",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0556e123_3ff4bd1f",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-26T16:40:47Z",
      "side": 1,
      "message": "\u003e The approach sounds interesting. However, I do not see in the above approach how we can prevent the eviction of hot entries after a restart.\n\nThis is the catch: after a restart, the in-memory \"hotCaches\" map will be empty and no entries will be hot.\nBut the point I was trying to make earlier is that perhaps we can live with it.\n\n- If Gerrit was shut down when chronicle-map was NOT running out of space[1], then it doesn\u0027t matter the hot-cache is empty, because we don\u0027t have to do space triggered evictions yet and the hot-cache will have time to populate itself.\n\n- If Gerrit was shut down when chronicle-map was running out of space[1], then *any* entry would be subject to eviction (only until we are not running out of space). The very first eviction might be sub-optimal because it *might* remove *some* entries that would have been potentially been hot, when Gerrit was running.\n\nAny eviction after that however will get incrementally more and more precise as the cache gets hot again.\n\nWDYT?\n\n[1] No more expansions are available (we reached max bloat factor) and the last expansion is already used over \"percentageFreeSpaceEvictionThreshold\". This has nothing to do with diskLimit, diskLimit is ignored, as per previous change in the chain.",
      "parentUuid": "e1b6f052_b0cab414",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02d00a2b_f2d34eb6",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValue.java",
        "patchSetId": 5
      },
      "lineNbr": 48,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-26T16:47:27Z",
      "side": 1,
      "message": "@luca this is what I was thinking, please take a look at this alternative implementation:\nhttps://gerrit-review.googlesource.com/c/modules/cache-chroniclemap/+/285734",
      "parentUuid": "0556e123_3ff4bd1f",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 48,
        "endChar": 0
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f005fa87_517ff214",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValueMarshaller.java",
        "patchSetId": 5
      },
      "lineNbr": 91,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-20T23:42:28Z",
      "side": 1,
      "message": "This isn\u0027t going to be good: we can\u0027t afford updating the value every single time we have a cache hit.\n\nWe need to keep that information somewhere else, possibly even just in memory and not persisted.",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 91,
        "endChar": 45
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "15839823_3300717e",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/TimedValueMarshaller.java",
        "patchSetId": 5
      },
      "lineNbr": 91,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-21T14:51:08Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "f005fa87_517ff214",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 91,
        "endChar": 45
      },
      "revId": "4f9732c333c71e87eca75e3fe62d35b25e656484",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}