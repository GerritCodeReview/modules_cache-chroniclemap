{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0bfb8c40_b3e947a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-29T21:03:05Z",
      "side": 1,
      "message": "This looks really promising :-) Thanks, Tony, for sharing it.",
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b2bad50_5b30b13e",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-29T21:03:05Z",
      "side": 1,
      "message": "Why would you put any value less than 100%?",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65b255e0_2171d9e7",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-30T16:43:36Z",
      "side": 1,
      "message": "When we reach 100% is too late, chronicle-map would have started throwing IllegalStateExceptions already.\n\nWe need go through evictions _before_ we hit that point, and because the pruning happens in a background routine task that runs every 30 seconds, this value needs to be configured \"early enough\" so that cache will not reach 100% in those 30 secs.\n\nDoes it make sense?",
      "parentUuid": "8b2bad50_5b30b13e",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "285f93d6_b9e837b6",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-30T23:32:44Z",
      "side": 1,
      "message": "I don\u0027t follow: why would it throw an IllegalStateException? Does that mean that if I allocate a cache of 100 entries, I cannot have more than 90? Why should we leave the last 10 empty?",
      "parentUuid": "65b255e0_2171d9e7",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3db773ea_8ac95106",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-02T10:57:23Z",
      "side": 1,
      "message": "\u003e I don\u0027t follow: why would it throw an IllegalStateException? \n\nFrom the documentation[1]\n\n```\nthe number of times in the future the map can expand its capacity of each segment (by expending its capacity we mean expending the maximum number of possible entries that can be stored into the map), the map will expand automatically.\n\nHowever, there is an upper limit to the number of times the map can expand. This limit is set via the net.openhft.chronicle.map.ChronicleMapBuilder#maxBloatFactor if the remainingAutoResizes drops to zero, then the map is no longer able to expand, if subsequently, the free space ( see percentageFreeSpace()) in the map becomes low ( around 5% ), the map will not be able to take more entries and will fail with an java.lang.IllegalStateException for production systems it is recommended you periodically monitor the remainingAutoResizes and percentageFreeSpace().\n```\n\n\u003e Does that mean that if I allocate a cache of 100 entries, I cannot have more than 90? Why should we leave the last 10 empty?\n\nYou can have more than 90 entries in the map, but (because the eviction routine gets triggered every 30 seconds) we want to leave a margin (between 90 and 100) to allow for additional entries to be inserted into the map between the execution of two eviction runs.\n\nImagine we left the threshold at 100:\nWe have 90 entries in the cache, eviction routine does not evict anything.\nIn the next 30 seconds, if just few entries get added to the cache, Gerrit would throw exceptions.\n\nLeaving (enough) margin ensures that scenario doesn\u0027t happen: how much that margin is, depend on how fast the cache can increase between eviction runs, and that\u0027s why I think it should be configurable.\n\nDoes it make any more sense?\n\n[1]https://javadoc.io/static/net.openhft/chronicle-map/3.20.83/net/openhft/chronicle/map/ChronicleMap.html#remainingAutoResizes--",
      "parentUuid": "285f93d6_b9e837b6",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dfc53e6_f7f2782a",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-11-03T20:58:59Z",
      "side": 1,
      "message": "Yes, it does make sense. Thanks for explaining it.\nIs it worth to include a link to that behaviour from the documentation? So that if people would ask the same question, they can have a valid reference?\n\nThanks for clarifying it.",
      "parentUuid": "3db773ea_8ac95106",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcdd38e7_e38410b0",
        "filename": "config.md",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-04T11:41:55Z",
      "side": 1,
      "message": "Yes, I will update the documentation to reflect this conversation.",
      "parentUuid": "0dfc53e6_f7f2782a",
      "range": {
        "startLine": 79,
        "startChar": 0,
        "endLine": 83,
        "endChar": 13
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85cd385e_307f9d57",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-29T21:03:05Z",
      "side": 1,
      "message": "Why should this be a fraction of the cache size? Do we consider \"hot\" only the 10% of the cache?\n\nYou could have a large section of the cache that is *really* cold because is never read from disk and, by limiting the hot entries to just 10%, you would risk to rather evict \"potentially hot\" entries rather than \"certainly cold\" ones.\n\nI would allocate to config.getMaxEntries(), full stop.\n\nWDYT?",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d83adb1a_0d4f8ad5",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-30T16:43:36Z",
      "side": 1,
      "message": "Ideally yes, but I didn\u0027t like the idea to have another copy of all cache keys in memory, which might consume a sizeable amount of memory.\n\nThis could be a problem for some Gerrit installations.\n\nI thought it was a trade-off that the Gerrit admin might want to consider:\nIf they don\u0027t care about the additional memory burden, they could always set this value to maxEntries.\n\nWDYT?",
      "parentUuid": "85cd385e_307f9d57",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da08cc72_302b5431",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-30T23:32:44Z",
      "side": 1,
      "message": "The key shouldn\u0027t that big after all, and we won\u0027t cache the value anyway.",
      "parentUuid": "d83adb1a_0d4f8ad5",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2949ecd4_87f54f81",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-02T10:57:23Z",
      "side": 1,
      "message": "How much memory it will occupy, really depends on the specific cache though, right?\n\nNew caches can be created by plugins (potentially with big keys for what we know) and, even if their key size is small, their _number_ can be high.\nAnd there can be _many_ caches, that will contribute to the overall memory fingerprint.\n\nHow about we set a default to config.getMaxEntries() and still allow the admins to change it, should they wish to?",
      "parentUuid": "da08cc72_302b5431",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4cf84e5_40ab47f1",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-02T14:41:44Z",
      "side": 1,
      "message": "I implemented this, let me know what you think.\n\nOne thing to notice though\n\n\nif chronicle-map was running out of space, the number of hot instance is likely going to be maxEntries (unless a restart just happened).\n\nThis means, that it will take O(maxEntries) time to evict one entry from chronicle-map, because the likelihood to find an entry that is not hot diminishes drastically.\n\nFor n entries, this goes back to quadratic complexity.\n\nI think it makes sense for the hotEntries to be just a small percentage of the total number of entries, so that eviction time is quicker.\n\nWDYT?",
      "parentUuid": "2949ecd4_87f54f81",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1dbbe99_eb61ae25",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-11-03T20:58:59Z",
      "side": 1,
      "message": "If the InMemoryLRU is optimised, it should be pretty quick to identify the oldest entries, isn\u0027t it? How do you estimate O(maxEntries)?",
      "parentUuid": "d4cf84e5_40ab47f1",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6134af46_56a2b806",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/ChronicleMapCacheImpl.java",
        "patchSetId": 2
      },
      "lineNbr": 55,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-04T11:41:55Z",
      "side": 1,
      "message": "I don\u0027t think so, because the eviction process requires looping through the _persisted entries_, not the InMemoryLRU.\n\nThis is the meta code for the evicting cold entries:\n\n// 1. loop through chronicle-map entries until we recovered enough space.\n// 2.    if entry is not in hotCache\n// 3.       remove entry.\n\nThe worst case of this algorithm is when all entries that are in chronicle-map are also in hotCache: this would cause that loop to go through *all* chronicle-map entries, which are `maxEntries`.\nThat\u0027s why I estimate a time complexity of O(maxEntries).\n\nIn fact, I believe the hotCaches *needs* to be lower than chronicle-map size because otherwise we won\u0027t be able to evict any entry:\nif everything is \"hot\" nothing can be flagged as \"cold\" and thus evicted. \n\nWDYT?",
      "parentUuid": "b1dbbe99_eb61ae25",
      "range": {
        "startLine": 55,
        "startChar": 74,
        "endLine": 55,
        "endChar": 79
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b73f4c1_797ff418",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-29T21:03:05Z",
      "side": 1,
      "message": "It should be a concurrent set, like [1].\n\n[1] https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.KeySetView.html",
      "range": {
        "startLine": 28,
        "startChar": 8,
        "endLine": 28,
        "endChar": 33
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e726f4c2_2ee47709",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-30T16:43:36Z",
      "side": 1,
      "message": "You\u0027re right about concurrency, but KeySetView does not provide an ordered data structure though, right?\n\nWe need that if we want to perform LRU on it.",
      "parentUuid": "2b73f4c1_797ff418",
      "range": {
        "startLine": 28,
        "startChar": 8,
        "endLine": 28,
        "endChar": 33
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fd2eb73_57727f92",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-11-03T20:58:59Z",
      "side": 1,
      "message": "Point taken, but you should at least create a synchronised map out of it:\n   Collections.synchronizedMap(new LinkedHashMap(...))\n\nAlso, you can keep it as LinkedHashMap so that you can use the useful methods for the LRU cache, like putIfAbsent(). As values, you can use a static dummy object, so that you won\u0027t use any extra heap memory for it.",
      "parentUuid": "e726f4c2_2ee47709",
      "range": {
        "startLine": 28,
        "startChar": 8,
        "endLine": 28,
        "endChar": 33
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "704d555b_6d9c5157",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-04T11:41:55Z",
      "side": 1,
      "message": "Makes sense, I will do, thanks Luca.",
      "parentUuid": "5fd2eb73_57727f92",
      "range": {
        "startLine": 28,
        "startChar": 8,
        "endLine": 28,
        "endChar": 33
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d8899c8_10ebc087",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-10-29T21:03:05Z",
      "side": 1,
      "message": "Apologies, I don\u0027t get this. Can you explain again why you need to remove and add again?",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 43,
        "endChar": 20
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ade646de_bfe84d34",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-10-30T16:43:36Z",
      "side": 1,
      "message": "It is because of this[1] behavior:\n\nNote that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)\n\nIf a key is already in the map, but it gets accessed again we want to update its its position in the ordered set.\n\n\n[1]https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html#LinkedHashMap(int,%20float,%20boolean)",
      "parentUuid": "4d8899c8_10ebc087",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 43,
        "endChar": 20
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a1c57f2_30448e2a",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2020-11-03T20:58:59Z",
      "side": 1,
      "message": "According to the documentation, if you use get() or getOrDefault() you would generate an access to the entry:\n\"This kind of map is well-suited to building LRU caches. Invoking the put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge methods results in an access to the corresponding entry (assuming it exists after the invocation completes).\"\n\nI would then change the code to simply:\n  set.putIfAbsent(objKey)",
      "parentUuid": "ade646de_bfe84d34",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 43,
        "endChar": 20
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e97b51f_967518a7",
        "filename": "src/main/java/com/googlesource/gerrit/modules/cache/chroniclemap/InMemoryLRUSet.java",
        "patchSetId": 2
      },
      "lineNbr": 43,
      "author": {
        "id": 1072905
      },
      "writtenOn": "2020-11-04T11:41:55Z",
      "side": 1,
      "message": "Thanks luca,\nI have also constructed the LinkedHashMap with the accessOrder flag now, to leverage this behaviour.\n\nhttps://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html#LinkedHashMap(int,%20float,%20boolean)",
      "parentUuid": "6a1c57f2_30448e2a",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 43,
        "endChar": 20
      },
      "revId": "53af8e9eabc939bcfb76e15e31799146f3e97dc5",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}